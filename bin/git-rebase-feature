#!/bin/sh

SRC=$(cd "$(dirname "$0")"; pwd)
source "${SRC}/common/print.sh"
source "${SRC}/common/submodules.sh"

print_help()
{
	print_info "Rebase root repository and all submodules on top of latest <rebase-branch>."
	print_info ""
	print_info "usage: git rebase-feature [<options>] <feature-branch> <rebase-branch>"
	print_info ""
	print_info "    -c, --continue	continue rebase after a conflict (only used internally)" 
}

rebase_submodules()
{
	get_submodules 
	current_dir=$PWD
	for submodule in $submodules_in_project; do
		cd $submodule
		print_info "Rebasing submodule $submodule"
		run_git checkout $rebase_branch
		run_git pull --rebase
		run_git checkout $feature_branch
		local hash=$(run_git rev-parse HEAD)
		run_git rebase $rebase_branch
		rebase_conflict=$?
		local new_hash=$(run_git rev-parse HEAD)

		if [ "$hash" == "$new_hash" ]
		then
			print_info "No commits to rebase!"
			echo $hash > .git.NO_REBASE_DONE # Set to avoid problems later when doing run_git reset --hard ORIG_HEAD
		else
			if (( $rebase_conflict > 0 ))
			then
				print_warning "$starting_mergetool"
				run_git mergetool
				cd $current_dir
				run_git rebase-feature --continue $feature_branch $rebase_branch
				return 1
			fi
		fi
		cd $current_dir
	done
	return 0
}

rebase_continue_submodules()
{
	get_submodules 
	current_dir=$PWD
	for submodule in $submodules_in_project; do
		cd $submodule
		print_info "Rebase continue submodule $submodule"
		if [ -e .git.NO_REBASE_DONE ]
		then
			print_info "No rebase to continue with"
		else
			if [ -d "../.git/modules/$submodule/rebase-apply" ]
			then
				print_info "Rebase continues"
				run_git add .
				run_git rebase --continue
				rebase_conflict=$?
				if (( $rebase_conflict > 0 ))
				then
					print_warning "$starting_mergetool"
					run_git mergetool
					cd $current_dir
					run_git rebase-feature --continue $feature_branch $rebase_branch
					return 1
				fi
			fi
		fi
		cd $current_dir
	done
	return 0
}

finish_submodules()
{
	get_submodules 
	current_dir=$PWD
	for submodule in $submodules_in_project; do
		cd $submodule
		if [ -e .git.NO_REBASE_DONE ]
		then
			rm .git.NO_REBASE_DONE
		else
			print_info "Push changes for $submodule"
			run_git push -f
			run_git reset --hard ORIG_HEAD
		fi
		cd $current_dir
	done
	echo "Done with submodules" > .git/SUBMODULES_DONE
}

reset_submodules()
{
	get_submodules 
	current_dir=$PWD
	for submodule in $submodules_in_project; do
		cd $submodule
		run_git reset --hard origin/$feature_branch
		cd $current_dir
	done
}

rebase_root()
{
	print_info "Rebasing root"
	run_git checkout $rebase_branch
	run_git pull --rebase
	run_git checkout $feature_branch
	run_git rebase $rebase_branch
	rebase_conflict=$?
	if (( $rebase_conflict > 0 ))
	then
		print_warning "$starting_mergetool"
		run_git mergetool
		run_git rebase-feature --continue $feature_branch $rebase_branch
		return 1
	fi
	return 0
}

rebase_continue_root()
{
	print_info "Continue rebase root"
	run_git add .
	run_git rebase --continue
	rebase_conflict=$?
	
	if (( $rebase_conflict > 0 ))
	then
		print_warning "$starting_mergetool"
		run_git mergetool
		run_git rebase-feature --continue $feature_branch $rebase_branch
		return 1
	fi
	return 0
}

push_root()
{
	print_info "Push changes in root"
	run_git add .
	run_git commit --amend --no-edit --allow-empty
	run_git push -f
}

rebase_done()
{
	rm .git/SUBMODULES_DONE
}

check_arguments()
{
	if [ $# -eq 0 ]
	then
		print_warning "<feature-branch> and <rebase-branch> are required"
		print_help
		exit 1
	fi

	if [ "$1" == "-h" ]
	then 
		print_help
		exit 0
	fi

	if [ -z $rebase_branch ]
	then
		rebase_branch=$2
		feature_branch=$1
		options=''
	fi

	if [ -z $rebase_branch ]
	then
		print_warning "feature-branch and rebase-branch is required"
		print_help
		exit 1
	fi
}

options=$1
feature_branch=$2
rebase_branch=$3

set_tabs

starting_mergetool="Starting mergetool"

check_arguments "$1" "$2" "$3"

if [ -z $options ]
then
	if [ -e .git/SUBMODULES_DONE ] 
	then 
		print_warning "You are in the middle of a rebase-feature"
		print_warning "If you have a clean repo you can remove the .git/SUBMODULES_DONE file manuaylly by typing rm -f .git/SUBMODULES_DONE"
		exit 1
	fi
	submodules_clean && 
	is_clean && 
	rebase_submodules && 
	finish_submodules &&
	rebase_root && 
	reset_submodules &&
	push_root && 
	rebase_done
elif [ "$options" == "-c" ] || [ "$options" == "--continue" ]
then
	if [ -e .git/SUBMODULES_DONE ] 
	then 
		rebase_continue_root &&
		reset_submodules &&
		push_root && 
		rebase_done
	else
		rebase_continue_submodules &&
		finish_submodules &&	
		rebase_root && 
		reset_submodules &&
		push_root &&
		rebase_done
	fi
fi